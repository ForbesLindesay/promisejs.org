{"version":3,"file":"/polyfills/promise-5.0.0.min.js.map","sources":["promise-5.0.0.js/node_modules/browserify/node_modules/browser-pack/_prelude.js","promise-5.0.0.js/node_modules/browserify/node_modules/process/browser.js","promise-5.0.0.js/node_modules/promise/core.js","promise-5.0.0.js/node_modules/promise/index.js","promise-5.0.0.js/node_modules/promise/node_modules/asap/asap.js","promise-5.0.0.js/polyfills/polyfill-done.js","promise-5.0.0.js/polyfills/polyfill.js"],"names":[],"mappings":"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","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","// shim for using process in browser\n\nvar process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n    && window.setImmediate;\n    var canPost = typeof window !== 'undefined'\n    && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener('message', function (ev) {\n            var source = ev.source;\n            if ((source === window || source === null) && ev.data === 'process-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('process-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n}\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\n","'use strict';\n\nvar asap = require('asap')\n\nmodule.exports = Promise\nfunction Promise(fn) {\n  if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new')\n  if (typeof fn !== 'function') throw new TypeError('not a function')\n  var state = null\n  var value = null\n  var deferreds = []\n  var self = this\n\n  this.then = function(onFulfilled, onRejected) {\n    return new Promise(function(resolve, reject) {\n      handle(new Handler(onFulfilled, onRejected, resolve, reject))\n    })\n  }\n\n  function handle(deferred) {\n    if (state === null) {\n      deferreds.push(deferred)\n      return\n    }\n    asap(function() {\n      var cb = state ? deferred.onFulfilled : deferred.onRejected\n      if (cb === null) {\n        (state ? deferred.resolve : deferred.reject)(value)\n        return\n      }\n      var ret\n      try {\n        ret = cb(value)\n      }\n      catch (e) {\n        deferred.reject(e)\n        return\n      }\n      deferred.resolve(ret)\n    })\n  }\n\n  function resolve(newValue) {\n    try { //Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.')\n      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {\n        var then = newValue.then\n        if (typeof then === 'function') {\n          doResolve(then.bind(newValue), resolve, reject)\n          return\n        }\n      }\n      state = true\n      value = newValue\n      finale()\n    } catch (e) { reject(e) }\n  }\n\n  function reject(newValue) {\n    state = false\n    value = newValue\n    finale()\n  }\n\n  function finale() {\n    for (var i = 0, len = deferreds.length; i < len; i++)\n      handle(deferreds[i])\n    deferreds = null\n  }\n\n  doResolve(fn, resolve, reject)\n}\n\n\nfunction Handler(onFulfilled, onRejected, resolve, reject){\n  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null\n  this.onRejected = typeof onRejected === 'function' ? onRejected : null\n  this.resolve = resolve\n  this.reject = reject\n}\n\n/**\n * Take a potentially misbehaving resolver function and make sure\n * onFulfilled and onRejected are only called once.\n *\n * Makes no guarantees about asynchrony.\n */\nfunction doResolve(fn, onFulfilled, onRejected) {\n  var done = false;\n  try {\n    fn(function (value) {\n      if (done) return\n      done = true\n      onFulfilled(value)\n    }, function (reason) {\n      if (done) return\n      done = true\n      onRejected(reason)\n    })\n  } catch (ex) {\n    if (done) return\n    done = true\n    onRejected(ex)\n  }\n}\n","'use strict';\n\n//This file contains then/promise specific extensions to the core promise API\n\nvar Promise = require('./core.js')\nvar asap = require('asap')\n\nmodule.exports = Promise\n\n/* Static Functions */\n\nfunction ValuePromise(value) {\n  this.then = function (onFulfilled) {\n    if (typeof onFulfilled !== 'function') return this\n    return new Promise(function (resolve, reject) {\n      asap(function () {\n        try {\n          resolve(onFulfilled(value))\n        } catch (ex) {\n          reject(ex);\n        }\n      })\n    })\n  }\n}\nValuePromise.prototype = Object.create(Promise.prototype)\n\nvar TRUE = new ValuePromise(true)\nvar FALSE = new ValuePromise(false)\nvar NULL = new ValuePromise(null)\nvar UNDEFINED = new ValuePromise(undefined)\nvar ZERO = new ValuePromise(0)\nvar EMPTYSTRING = new ValuePromise('')\n\nPromise.resolve = function (value) {\n  if (value instanceof Promise) return value\n\n  if (value === null) return NULL\n  if (value === undefined) return UNDEFINED\n  if (value === true) return TRUE\n  if (value === false) return FALSE\n  if (value === 0) return ZERO\n  if (value === '') return EMPTYSTRING\n\n  if (typeof value === 'object' || typeof value === 'function') {\n    try {\n      var then = value.then\n      if (typeof then === 'function') {\n        return new Promise(then.bind(value))\n      }\n    } catch (ex) {\n      return new Promise(function (resolve, reject) {\n        reject(ex)\n      })\n    }\n  }\n\n  return new ValuePromise(value)\n}\n\nPromise.from = Promise.cast = function (value) {\n  var err = new Error('Promise.from and Promise.cast are deprecated, use Promise.resolve instead')\n  err.name = 'Warning'\n  console.warn(err.stack)\n  return Promise.resolve(value)\n}\n\nPromise.denodeify = function (fn, argumentCount) {\n  argumentCount = argumentCount || Infinity\n  return function () {\n    var self = this\n    var args = Array.prototype.slice.call(arguments)\n    return new Promise(function (resolve, reject) {\n      while (args.length && args.length > argumentCount) {\n        args.pop()\n      }\n      args.push(function (err, res) {\n        if (err) reject(err)\n        else resolve(res)\n      })\n      fn.apply(self, args)\n    })\n  }\n}\nPromise.nodeify = function (fn) {\n  return function () {\n    var args = Array.prototype.slice.call(arguments)\n    var callback = typeof args[args.length - 1] === 'function' ? args.pop() : null\n    try {\n      return fn.apply(this, arguments).nodeify(callback)\n    } catch (ex) {\n      if (callback === null || typeof callback == 'undefined') {\n        return new Promise(function (resolve, reject) { reject(ex) })\n      } else {\n        asap(function () {\n          callback(ex)\n        })\n      }\n    }\n  }\n}\n\nPromise.all = function () {\n  var calledWithArray = arguments.length === 1 && Array.isArray(arguments[0])\n  var args = Array.prototype.slice.call(calledWithArray ? arguments[0] : arguments)\n\n  if (!calledWithArray) {\n    var err = new Error('Promise.all should be called with a single array, calling it with multiple arguments is deprecated')\n    err.name = 'Warning'\n    console.warn(err.stack)\n  }\n\n  return new Promise(function (resolve, reject) {\n    if (args.length === 0) return resolve([])\n    var remaining = args.length\n    function res(i, val) {\n      try {\n        if (val && (typeof val === 'object' || typeof val === 'function')) {\n          var then = val.then\n          if (typeof then === 'function') {\n            then.call(val, function (val) { res(i, val) }, reject)\n            return\n          }\n        }\n        args[i] = val\n        if (--remaining === 0) {\n          resolve(args);\n        }\n      } catch (ex) {\n        reject(ex)\n      }\n    }\n    for (var i = 0; i < args.length; i++) {\n      res(i, args[i])\n    }\n  })\n}\n\nPromise.reject = function (value) {\n  return new Promise(function (resolve, reject) { \n    reject(value);\n  });\n}\n\nPromise.race = function (values) {\n  return new Promise(function (resolve, reject) { \n    values.forEach(function(value){\n      Promise.resolve(value).then(resolve, reject);\n    })\n  });\n}\n\n/* Prototype Methods */\n\nPromise.prototype.done = function (onFulfilled, onRejected) {\n  var self = arguments.length ? this.then.apply(this, arguments) : this\n  self.then(null, function (err) {\n    asap(function () {\n      throw err\n    })\n  })\n}\n\nPromise.prototype.nodeify = function (callback) {\n  if (typeof callback != 'function') return this\n\n  this.then(function (value) {\n    asap(function () {\n      callback(null, value)\n    })\n  }, function (err) {\n    asap(function () {\n      callback(err)\n    })\n  })\n}\n\nPromise.prototype['catch'] = function (onRejected) {\n  return this.then(null, onRejected);\n}\n","(function (process){\n\n// Use the fastest possible means to execute a task in a future turn\n// of the event loop.\n\n// linked list of tasks (single, with head node)\nvar head = {task: void 0, next: null};\nvar tail = head;\nvar flushing = false;\nvar requestFlush = void 0;\nvar isNodeJS = false;\n\nfunction flush() {\n    /* jshint loopfunc: true */\n\n    while (head.next) {\n        head = head.next;\n        var task = head.task;\n        head.task = void 0;\n        var domain = head.domain;\n\n        if (domain) {\n            head.domain = void 0;\n            domain.enter();\n        }\n\n        try {\n            task();\n\n        } catch (e) {\n            if (isNodeJS) {\n                // In node, uncaught exceptions are considered fatal errors.\n                // Re-throw them synchronously to interrupt flushing!\n\n                // Ensure continuation if the uncaught exception is suppressed\n                // listening \"uncaughtException\" events (as domains does).\n                // Continue in next event to avoid tick recursion.\n                if (domain) {\n                    domain.exit();\n                }\n                setTimeout(flush, 0);\n                if (domain) {\n                    domain.enter();\n                }\n\n                throw e;\n\n            } else {\n                // In browsers, uncaught exceptions are not fatal.\n                // Re-throw them asynchronously to avoid slow-downs.\n                setTimeout(function() {\n                   throw e;\n                }, 0);\n            }\n        }\n\n        if (domain) {\n            domain.exit();\n        }\n    }\n\n    flushing = false;\n}\n\nif (typeof process !== \"undefined\" && process.nextTick) {\n    // Node.js before 0.9. Note that some fake-Node environments, like the\n    // Mocha test runner, introduce a `process` global without a `nextTick`.\n    isNodeJS = true;\n\n    requestFlush = function () {\n        process.nextTick(flush);\n    };\n\n} else if (typeof setImmediate === \"function\") {\n    // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate\n    if (typeof window !== \"undefined\") {\n        requestFlush = setImmediate.bind(window, flush);\n    } else {\n        requestFlush = function () {\n            setImmediate(flush);\n        };\n    }\n\n} else if (typeof MessageChannel !== \"undefined\") {\n    // modern browsers\n    // http://www.nonblocking.io/2011/06/windownexttick.html\n    var channel = new MessageChannel();\n    channel.port1.onmessage = flush;\n    requestFlush = function () {\n        channel.port2.postMessage(0);\n    };\n\n} else {\n    // old browsers\n    requestFlush = function () {\n        setTimeout(flush, 0);\n    };\n}\n\nfunction asap(task) {\n    tail = tail.next = {\n        task: task,\n        domain: isNodeJS && process.domain,\n        next: null\n    };\n\n    if (!flushing) {\n        flushing = true;\n        requestFlush();\n    }\n};\n\nmodule.exports = asap;\n\n\n}).call(this,require('_process'))","if (!Promise.prototype.done) {\r\n  Promise.prototype.done = function (cb, eb) {\r\n    var promise = (typeof cb === 'function' || typeof eb === 'function') ?\r\n        this.then(cb, eb) : this;\r\n    promise.then(null, function (err) {\r\n      setTimeout(function () {\r\n        throw err;\r\n      }, 0);\r\n    });\r\n  };\r\n}\r\n","if (typeof Promise === 'undefined') {\r\n  Promise = require('promise');\r\n} else {\r\n  require('./polyfill-done.js');\r\n}"]}